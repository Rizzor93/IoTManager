// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IoT.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_IoT_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_IoT_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_IoT_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_IoT_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_IoT_2eproto;
namespace proto {
class Device;
struct DeviceDefaultTypeInternal;
extern DeviceDefaultTypeInternal _Device_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class Record;
struct RecordDefaultTypeInternal;
extern RecordDefaultTypeInternal _Record_default_instance_;
class RecordData;
struct RecordDataDefaultTypeInternal;
extern RecordDataDefaultTypeInternal _RecordData_default_instance_;
class RecordDataFilter;
struct RecordDataFilterDefaultTypeInternal;
extern RecordDataFilterDefaultTypeInternal _RecordDataFilter_default_instance_;
class RecordSensor;
struct RecordSensorDefaultTypeInternal;
extern RecordSensorDefaultTypeInternal _RecordSensor_default_instance_;
class Sensor;
struct SensorDefaultTypeInternal;
extern SensorDefaultTypeInternal _Sensor_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::Device* Arena::CreateMaybeMessage<::proto::Device>(Arena*);
template<> ::proto::Empty* Arena::CreateMaybeMessage<::proto::Empty>(Arena*);
template<> ::proto::Record* Arena::CreateMaybeMessage<::proto::Record>(Arena*);
template<> ::proto::RecordData* Arena::CreateMaybeMessage<::proto::RecordData>(Arena*);
template<> ::proto::RecordDataFilter* Arena::CreateMaybeMessage<::proto::RecordDataFilter>(Arena*);
template<> ::proto::RecordSensor* Arena::CreateMaybeMessage<::proto::RecordSensor>(Arena*);
template<> ::proto::Sensor* Arena::CreateMaybeMessage<::proto::Sensor>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

enum DeviceType : int {
  ARDUINO = 0,
  RASPBERRYPI = 1,
  PLC_Siemens = 2,
  PLC_Beckhoff = 3,
  PLC_WAGO = 4,
  OPC = 5,
  DeviceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DeviceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DeviceType_IsValid(int value);
constexpr DeviceType DeviceType_MIN = ARDUINO;
constexpr DeviceType DeviceType_MAX = OPC;
constexpr int DeviceType_ARRAYSIZE = DeviceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeviceType_descriptor();
template<typename T>
inline const std::string& DeviceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DeviceType_descriptor(), enum_t_value);
}
inline bool DeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DeviceType>(
    DeviceType_descriptor(), name, value);
}
enum SensorDataType : int {
  BOOL = 0,
  BYTE = 1,
  INT = 2,
  FLOAT = 3,
  DOUBLE = 4,
  STRING = 5,
  DATETIME = 6,
  SensorDataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SensorDataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SensorDataType_IsValid(int value);
constexpr SensorDataType SensorDataType_MIN = BOOL;
constexpr SensorDataType SensorDataType_MAX = DATETIME;
constexpr int SensorDataType_ARRAYSIZE = SensorDataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorDataType_descriptor();
template<typename T>
inline const std::string& SensorDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SensorDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SensorDataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SensorDataType_descriptor(), enum_t_value);
}
inline bool SensorDataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SensorDataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SensorDataType>(
    SensorDataType_descriptor(), name, value);
}
enum GPIOType : int {
  Input = 0,
  Output = 1,
  AnalogInput = 2,
  AnalogOutput = 3,
  GPIOType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GPIOType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GPIOType_IsValid(int value);
constexpr GPIOType GPIOType_MIN = Input;
constexpr GPIOType GPIOType_MAX = AnalogOutput;
constexpr int GPIOType_ARRAYSIZE = GPIOType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GPIOType_descriptor();
template<typename T>
inline const std::string& GPIOType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GPIOType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GPIOType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GPIOType_descriptor(), enum_t_value);
}
inline bool GPIOType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GPIOType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GPIOType>(
    GPIOType_descriptor(), name, value);
}
enum PLCDataArea : int {
  DB = 0,
  MK = 1,
  PE = 2,
  PA = 3,
  CT = 4,
  PLCDataArea_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PLCDataArea_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PLCDataArea_IsValid(int value);
constexpr PLCDataArea PLCDataArea_MIN = DB;
constexpr PLCDataArea PLCDataArea_MAX = CT;
constexpr int PLCDataArea_ARRAYSIZE = PLCDataArea_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PLCDataArea_descriptor();
template<typename T>
inline const std::string& PLCDataArea_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PLCDataArea>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PLCDataArea_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PLCDataArea_descriptor(), enum_t_value);
}
inline bool PLCDataArea_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PLCDataArea* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PLCDataArea>(
    PLCDataArea_descriptor(), name, value);
}
enum RecordType : int {
  EQUAL = 0,
  ODD = 1,
  SMALLER_THEN = 2,
  BIGGER_THEN = 3,
  RANGE = 4,
  ALWAYS = 5,
  RecordType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RecordType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RecordType_IsValid(int value);
constexpr RecordType RecordType_MIN = EQUAL;
constexpr RecordType RecordType_MAX = ALWAYS;
constexpr int RecordType_ARRAYSIZE = RecordType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RecordType_descriptor();
template<typename T>
inline const std::string& RecordType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RecordType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RecordType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RecordType_descriptor(), enum_t_value);
}
inline bool RecordType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RecordType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RecordType>(
    RecordType_descriptor(), name, value);
}
enum FilterTime : int {
  NOW = 0,
  LAST_24H = 1,
  LAST_WEEK = 2,
  LAST_MONTH = 3,
  LAST_3MONTH = 4,
  LAST_6MONTH = 5,
  LAST_YEAR = 6,
  ALL = 7,
  FilterTime_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FilterTime_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FilterTime_IsValid(int value);
constexpr FilterTime FilterTime_MIN = NOW;
constexpr FilterTime FilterTime_MAX = ALL;
constexpr int FilterTime_ARRAYSIZE = FilterTime_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FilterTime_descriptor();
template<typename T>
inline const std::string& FilterTime_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FilterTime>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FilterTime_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FilterTime_descriptor(), enum_t_value);
}
inline bool FilterTime_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FilterTime* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FilterTime>(
    FilterTime_descriptor(), name, value);
}
enum FilterValue : int {
  EQUAL_VALUE = 0,
  ODD_VALUE = 1,
  SMALLER_THEN_VALUE = 2,
  BIGGER_THEN_VALUE = 3,
  RANGE_VALUE = 4,
  ALL_VALUE = 5,
  FilterValue_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FilterValue_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FilterValue_IsValid(int value);
constexpr FilterValue FilterValue_MIN = EQUAL_VALUE;
constexpr FilterValue FilterValue_MAX = ALL_VALUE;
constexpr int FilterValue_ARRAYSIZE = FilterValue_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FilterValue_descriptor();
template<typename T>
inline const std::string& FilterValue_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FilterValue>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FilterValue_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FilterValue_descriptor(), enum_t_value);
}
inline bool FilterValue_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FilterValue* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FilterValue>(
    FilterValue_descriptor(), name, value);
}
// ===================================================================

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  ~Empty() override;
  explicit constexpr Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return new Empty();
  }

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Empty& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Empty& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Empty* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IoT_2eproto;
};
// -------------------------------------------------------------------

class Device final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Device) */ {
 public:
  inline Device() : Device(nullptr) {}
  ~Device() override;
  explicit constexpr Device(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Device(const Device& from);
  Device(Device&& from) noexcept
    : Device() {
    *this = ::std::move(from);
  }

  inline Device& operator=(const Device& from) {
    CopyFrom(from);
    return *this;
  }
  inline Device& operator=(Device&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Device& default_instance() {
    return *internal_default_instance();
  }
  static inline const Device* internal_default_instance() {
    return reinterpret_cast<const Device*>(
               &_Device_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Device& a, Device& b) {
    a.Swap(&b);
  }
  inline void Swap(Device* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Device* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Device* New() const final {
    return new Device();
  }

  Device* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Device>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Device& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Device& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Device* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Device";
  }
  protected:
  explicit Device(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kLocationFieldNumber = 3,
    kIPAddressFieldNumber = 5,
    kGatewayFieldNumber = 6,
    kSubnetMaskFieldNumber = 7,
    kOPCUrlFieldNumber = 8,
    kIDFieldNumber = 1,
    kDeviceTypeFieldNumber = 4,
  };
  // string Name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string Location = 3;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_MUST_USE_RESULT std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // string IPAddress = 5;
  void clear_ipaddress();
  const std::string& ipaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ipaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ipaddress();
  PROTOBUF_MUST_USE_RESULT std::string* release_ipaddress();
  void set_allocated_ipaddress(std::string* ipaddress);
  private:
  const std::string& _internal_ipaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ipaddress(const std::string& value);
  std::string* _internal_mutable_ipaddress();
  public:

  // string Gateway = 6;
  void clear_gateway();
  const std::string& gateway() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gateway(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gateway();
  PROTOBUF_MUST_USE_RESULT std::string* release_gateway();
  void set_allocated_gateway(std::string* gateway);
  private:
  const std::string& _internal_gateway() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gateway(const std::string& value);
  std::string* _internal_mutable_gateway();
  public:

  // string SubnetMask = 7;
  void clear_subnetmask();
  const std::string& subnetmask() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subnetmask(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subnetmask();
  PROTOBUF_MUST_USE_RESULT std::string* release_subnetmask();
  void set_allocated_subnetmask(std::string* subnetmask);
  private:
  const std::string& _internal_subnetmask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subnetmask(const std::string& value);
  std::string* _internal_mutable_subnetmask();
  public:

  // string OPCUrl = 8;
  void clear_opcurl();
  const std::string& opcurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_opcurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_opcurl();
  PROTOBUF_MUST_USE_RESULT std::string* release_opcurl();
  void set_allocated_opcurl(std::string* opcurl);
  private:
  const std::string& _internal_opcurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_opcurl(const std::string& value);
  std::string* _internal_mutable_opcurl();
  public:

  // uint32 ID = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .proto.DeviceType DeviceType = 4;
  void clear_devicetype();
  ::proto::DeviceType devicetype() const;
  void set_devicetype(::proto::DeviceType value);
  private:
  ::proto::DeviceType _internal_devicetype() const;
  void _internal_set_devicetype(::proto::DeviceType value);
  public:

  // @@protoc_insertion_point(class_scope:proto.Device)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipaddress_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gateway_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subnetmask_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr opcurl_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  int devicetype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IoT_2eproto;
};
// -------------------------------------------------------------------

class Sensor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Sensor) */ {
 public:
  inline Sensor() : Sensor(nullptr) {}
  ~Sensor() override;
  explicit constexpr Sensor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sensor(const Sensor& from);
  Sensor(Sensor&& from) noexcept
    : Sensor() {
    *this = ::std::move(from);
  }

  inline Sensor& operator=(const Sensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sensor& operator=(Sensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sensor* internal_default_instance() {
    return reinterpret_cast<const Sensor*>(
               &_Sensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Sensor& a, Sensor& b) {
    a.Swap(&b);
  }
  inline void Swap(Sensor* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Sensor* New() const final {
    return new Sensor();
  }

  Sensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Sensor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Sensor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Sensor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sensor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Sensor";
  }
  protected:
  explicit Sensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kLocationFieldNumber = 4,
    kNodeIDFieldNumber = 13,
    kIDFieldNumber = 1,
    kDeviceIDFieldNumber = 2,
    kDataTypeFieldNumber = 5,
    kGPIONumFieldNumber = 6,
    kGPIOTypeFieldNumber = 7,
    kPullUpResistorFieldNumber = 8,
    kPLCDataAreaFieldNumber = 9,
    kDataOffsetFieldNumber = 10,
    kBoolIndexFieldNumber = 11,
    kDbNumFieldNumber = 12,
  };
  // string Name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string Location = 4;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_MUST_USE_RESULT std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // string NodeID = 13;
  void clear_nodeid();
  const std::string& nodeid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nodeid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nodeid();
  PROTOBUF_MUST_USE_RESULT std::string* release_nodeid();
  void set_allocated_nodeid(std::string* nodeid);
  private:
  const std::string& _internal_nodeid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nodeid(const std::string& value);
  std::string* _internal_mutable_nodeid();
  public:

  // uint32 ID = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 DeviceID = 2;
  void clear_deviceid();
  ::PROTOBUF_NAMESPACE_ID::uint32 deviceid() const;
  void set_deviceid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_deviceid() const;
  void _internal_set_deviceid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .proto.SensorDataType DataType = 5;
  void clear_datatype();
  ::proto::SensorDataType datatype() const;
  void set_datatype(::proto::SensorDataType value);
  private:
  ::proto::SensorDataType _internal_datatype() const;
  void _internal_set_datatype(::proto::SensorDataType value);
  public:

  // int32 GPIONum = 6;
  void clear_gpionum();
  ::PROTOBUF_NAMESPACE_ID::int32 gpionum() const;
  void set_gpionum(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_gpionum() const;
  void _internal_set_gpionum(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .proto.GPIOType GPIOType = 7;
  void clear_gpiotype();
  ::proto::GPIOType gpiotype() const;
  void set_gpiotype(::proto::GPIOType value);
  private:
  ::proto::GPIOType _internal_gpiotype() const;
  void _internal_set_gpiotype(::proto::GPIOType value);
  public:

  // bool PullUpResistor = 8;
  void clear_pullupresistor();
  bool pullupresistor() const;
  void set_pullupresistor(bool value);
  private:
  bool _internal_pullupresistor() const;
  void _internal_set_pullupresistor(bool value);
  public:

  // .proto.PLCDataArea PLCDataArea = 9;
  void clear_plcdataarea();
  ::proto::PLCDataArea plcdataarea() const;
  void set_plcdataarea(::proto::PLCDataArea value);
  private:
  ::proto::PLCDataArea _internal_plcdataarea() const;
  void _internal_set_plcdataarea(::proto::PLCDataArea value);
  public:

  // int32 DataOffset = 10;
  void clear_dataoffset();
  ::PROTOBUF_NAMESPACE_ID::int32 dataoffset() const;
  void set_dataoffset(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_dataoffset() const;
  void _internal_set_dataoffset(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 BoolIndex = 11;
  void clear_boolindex();
  ::PROTOBUF_NAMESPACE_ID::int32 boolindex() const;
  void set_boolindex(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_boolindex() const;
  void _internal_set_boolindex(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 DbNum = 12;
  void clear_dbnum();
  ::PROTOBUF_NAMESPACE_ID::int32 dbnum() const;
  void set_dbnum(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_dbnum() const;
  void _internal_set_dbnum(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:proto.Sensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodeid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 deviceid_;
  int datatype_;
  ::PROTOBUF_NAMESPACE_ID::int32 gpionum_;
  int gpiotype_;
  bool pullupresistor_;
  int plcdataarea_;
  ::PROTOBUF_NAMESPACE_ID::int32 dataoffset_;
  ::PROTOBUF_NAMESPACE_ID::int32 boolindex_;
  ::PROTOBUF_NAMESPACE_ID::int32 dbnum_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IoT_2eproto;
};
// -------------------------------------------------------------------

class Record final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Record) */ {
 public:
  inline Record() : Record(nullptr) {}
  ~Record() override;
  explicit constexpr Record(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Record(const Record& from);
  Record(Record&& from) noexcept
    : Record() {
    *this = ::std::move(from);
  }

  inline Record& operator=(const Record& from) {
    CopyFrom(from);
    return *this;
  }
  inline Record& operator=(Record&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Record& default_instance() {
    return *internal_default_instance();
  }
  static inline const Record* internal_default_instance() {
    return reinterpret_cast<const Record*>(
               &_Record_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Record& a, Record& b) {
    a.Swap(&b);
  }
  inline void Swap(Record* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Record* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Record* New() const final {
    return new Record();
  }

  Record* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Record>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Record& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Record& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Record* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Record";
  }
  protected:
  explicit Record(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordSensorFieldNumber = 5,
    kNameFieldNumber = 3,
    kIDFieldNumber = 1,
    kDeviceIDFieldNumber = 2,
    kRunningFieldNumber = 4,
  };
  // repeated .proto.RecordSensor RecordSensor = 5;
  int recordsensor_size() const;
  private:
  int _internal_recordsensor_size() const;
  public:
  void clear_recordsensor();
  ::proto::RecordSensor* mutable_recordsensor(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::RecordSensor >*
      mutable_recordsensor();
  private:
  const ::proto::RecordSensor& _internal_recordsensor(int index) const;
  ::proto::RecordSensor* _internal_add_recordsensor();
  public:
  const ::proto::RecordSensor& recordsensor(int index) const;
  ::proto::RecordSensor* add_recordsensor();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::RecordSensor >&
      recordsensor() const;

  // string Name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 ID = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 DeviceID = 2;
  void clear_deviceid();
  ::PROTOBUF_NAMESPACE_ID::uint32 deviceid() const;
  void set_deviceid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_deviceid() const;
  void _internal_set_deviceid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool Running = 4;
  void clear_running();
  bool running() const;
  void set_running(bool value);
  private:
  bool _internal_running() const;
  void _internal_set_running(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.Record)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::RecordSensor > recordsensor_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 deviceid_;
  bool running_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IoT_2eproto;
};
// -------------------------------------------------------------------

class RecordSensor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.RecordSensor) */ {
 public:
  inline RecordSensor() : RecordSensor(nullptr) {}
  ~RecordSensor() override;
  explicit constexpr RecordSensor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordSensor(const RecordSensor& from);
  RecordSensor(RecordSensor&& from) noexcept
    : RecordSensor() {
    *this = ::std::move(from);
  }

  inline RecordSensor& operator=(const RecordSensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordSensor& operator=(RecordSensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordSensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordSensor* internal_default_instance() {
    return reinterpret_cast<const RecordSensor*>(
               &_RecordSensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RecordSensor& a, RecordSensor& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordSensor* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordSensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RecordSensor* New() const final {
    return new RecordSensor();
  }

  RecordSensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecordSensor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordSensor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RecordSensor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordSensor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RecordSensor";
  }
  protected:
  explicit RecordSensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTriggerValueMinFieldNumber = 3,
    kTriggerValueMaxFieldNumber = 4,
    kSensorIDFieldNumber = 1,
    kRecordTypeFieldNumber = 2,
    kIntervalFieldNumber = 5,
  };
  // string TriggerValueMin = 3;
  void clear_triggervaluemin();
  const std::string& triggervaluemin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_triggervaluemin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_triggervaluemin();
  PROTOBUF_MUST_USE_RESULT std::string* release_triggervaluemin();
  void set_allocated_triggervaluemin(std::string* triggervaluemin);
  private:
  const std::string& _internal_triggervaluemin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_triggervaluemin(const std::string& value);
  std::string* _internal_mutable_triggervaluemin();
  public:

  // string TriggerValueMax = 4;
  void clear_triggervaluemax();
  const std::string& triggervaluemax() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_triggervaluemax(ArgT0&& arg0, ArgT... args);
  std::string* mutable_triggervaluemax();
  PROTOBUF_MUST_USE_RESULT std::string* release_triggervaluemax();
  void set_allocated_triggervaluemax(std::string* triggervaluemax);
  private:
  const std::string& _internal_triggervaluemax() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_triggervaluemax(const std::string& value);
  std::string* _internal_mutable_triggervaluemax();
  public:

  // uint32 SensorID = 1;
  void clear_sensorid();
  ::PROTOBUF_NAMESPACE_ID::uint32 sensorid() const;
  void set_sensorid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sensorid() const;
  void _internal_set_sensorid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .proto.RecordType RecordType = 2;
  void clear_recordtype();
  ::proto::RecordType recordtype() const;
  void set_recordtype(::proto::RecordType value);
  private:
  ::proto::RecordType _internal_recordtype() const;
  void _internal_set_recordtype(::proto::RecordType value);
  public:

  // double interval = 5;
  void clear_interval();
  double interval() const;
  void set_interval(double value);
  private:
  double _internal_interval() const;
  void _internal_set_interval(double value);
  public:

  // @@protoc_insertion_point(class_scope:proto.RecordSensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr triggervaluemin_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr triggervaluemax_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensorid_;
  int recordtype_;
  double interval_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IoT_2eproto;
};
// -------------------------------------------------------------------

class RecordData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.RecordData) */ {
 public:
  inline RecordData() : RecordData(nullptr) {}
  ~RecordData() override;
  explicit constexpr RecordData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordData(const RecordData& from);
  RecordData(RecordData&& from) noexcept
    : RecordData() {
    *this = ::std::move(from);
  }

  inline RecordData& operator=(const RecordData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordData& operator=(RecordData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordData* internal_default_instance() {
    return reinterpret_cast<const RecordData*>(
               &_RecordData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RecordData& a, RecordData& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RecordData* New() const final {
    return new RecordData();
  }

  RecordData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecordData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RecordData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RecordData";
  }
  protected:
  explicit RecordData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 4,
    kTimestampFieldNumber = 5,
    kIDFieldNumber = 1,
    kSensorIDFieldNumber = 2,
    kDataTypeFieldNumber = 3,
  };
  // string Value = 4;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .google.protobuf.Timestamp Timestamp = 5;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // uint32 ID = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 SensorID = 2;
  void clear_sensorid();
  ::PROTOBUF_NAMESPACE_ID::uint32 sensorid() const;
  void set_sensorid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sensorid() const;
  void _internal_set_sensorid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .proto.SensorDataType DataType = 3;
  void clear_datatype();
  ::proto::SensorDataType datatype() const;
  void set_datatype(::proto::SensorDataType value);
  private:
  ::proto::SensorDataType _internal_datatype() const;
  void _internal_set_datatype(::proto::SensorDataType value);
  public:

  // @@protoc_insertion_point(class_scope:proto.RecordData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensorid_;
  int datatype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IoT_2eproto;
};
// -------------------------------------------------------------------

class RecordDataFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.RecordDataFilter) */ {
 public:
  inline RecordDataFilter() : RecordDataFilter(nullptr) {}
  ~RecordDataFilter() override;
  explicit constexpr RecordDataFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordDataFilter(const RecordDataFilter& from);
  RecordDataFilter(RecordDataFilter&& from) noexcept
    : RecordDataFilter() {
    *this = ::std::move(from);
  }

  inline RecordDataFilter& operator=(const RecordDataFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordDataFilter& operator=(RecordDataFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordDataFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordDataFilter* internal_default_instance() {
    return reinterpret_cast<const RecordDataFilter*>(
               &_RecordDataFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RecordDataFilter& a, RecordDataFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordDataFilter* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordDataFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RecordDataFilter* New() const final {
    return new RecordDataFilter();
  }

  RecordDataFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecordDataFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordDataFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RecordDataFilter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordDataFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RecordDataFilter";
  }
  protected:
  explicit RecordDataFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinValueFieldNumber = 4,
    kMaxValueFieldNumber = 6,
    kIDFieldNumber = 1,
    kSensorIDFieldNumber = 2,
    kFilterValueFieldNumber = 3,
    kFilterTimeFieldNumber = 8,
  };
  // string MinValue = 4;
  void clear_minvalue();
  const std::string& minvalue() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_minvalue(ArgT0&& arg0, ArgT... args);
  std::string* mutable_minvalue();
  PROTOBUF_MUST_USE_RESULT std::string* release_minvalue();
  void set_allocated_minvalue(std::string* minvalue);
  private:
  const std::string& _internal_minvalue() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_minvalue(const std::string& value);
  std::string* _internal_mutable_minvalue();
  public:

  // string MaxValue = 6;
  void clear_maxvalue();
  const std::string& maxvalue() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_maxvalue(ArgT0&& arg0, ArgT... args);
  std::string* mutable_maxvalue();
  PROTOBUF_MUST_USE_RESULT std::string* release_maxvalue();
  void set_allocated_maxvalue(std::string* maxvalue);
  private:
  const std::string& _internal_maxvalue() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maxvalue(const std::string& value);
  std::string* _internal_mutable_maxvalue();
  public:

  // uint32 ID = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 SensorID = 2;
  void clear_sensorid();
  ::PROTOBUF_NAMESPACE_ID::uint32 sensorid() const;
  void set_sensorid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sensorid() const;
  void _internal_set_sensorid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .proto.FilterValue FilterValue = 3;
  void clear_filtervalue();
  ::proto::FilterValue filtervalue() const;
  void set_filtervalue(::proto::FilterValue value);
  private:
  ::proto::FilterValue _internal_filtervalue() const;
  void _internal_set_filtervalue(::proto::FilterValue value);
  public:

  // .proto.FilterTime FilterTime = 8;
  void clear_filtertime();
  ::proto::FilterTime filtertime() const;
  void set_filtertime(::proto::FilterTime value);
  private:
  ::proto::FilterTime _internal_filtertime() const;
  void _internal_set_filtertime(::proto::FilterTime value);
  public:

  // @@protoc_insertion_point(class_scope:proto.RecordDataFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr minvalue_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maxvalue_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensorid_;
  int filtervalue_;
  int filtertime_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IoT_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Empty

// -------------------------------------------------------------------

// Device

// uint32 ID = 1;
inline void Device::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Device::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Device::id() const {
  // @@protoc_insertion_point(field_get:proto.Device.ID)
  return _internal_id();
}
inline void Device::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void Device::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:proto.Device.ID)
}

// string Name = 2;
inline void Device::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Device::name() const {
  // @@protoc_insertion_point(field_get:proto.Device.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Device::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Device.Name)
}
inline std::string* Device::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.Device.Name)
  return _s;
}
inline const std::string& Device::_internal_name() const {
  return name_.Get();
}
inline void Device::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Device::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Device::release_name() {
  // @@protoc_insertion_point(field_release:proto.Device.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Device::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:proto.Device.Name)
}

// string Location = 3;
inline void Device::clear_location() {
  location_.ClearToEmpty();
}
inline const std::string& Device::location() const {
  // @@protoc_insertion_point(field_get:proto.Device.Location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Device::set_location(ArgT0&& arg0, ArgT... args) {
 
 location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Device.Location)
}
inline std::string* Device::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:proto.Device.Location)
  return _s;
}
inline const std::string& Device::_internal_location() const {
  return location_.Get();
}
inline void Device::_internal_set_location(const std::string& value) {
  
  location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Device::_internal_mutable_location() {
  
  return location_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Device::release_location() {
  // @@protoc_insertion_point(field_release:proto.Device.Location)
  return location_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Device::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  location_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), location,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:proto.Device.Location)
}

// .proto.DeviceType DeviceType = 4;
inline void Device::clear_devicetype() {
  devicetype_ = 0;
}
inline ::proto::DeviceType Device::_internal_devicetype() const {
  return static_cast< ::proto::DeviceType >(devicetype_);
}
inline ::proto::DeviceType Device::devicetype() const {
  // @@protoc_insertion_point(field_get:proto.Device.DeviceType)
  return _internal_devicetype();
}
inline void Device::_internal_set_devicetype(::proto::DeviceType value) {
  
  devicetype_ = value;
}
inline void Device::set_devicetype(::proto::DeviceType value) {
  _internal_set_devicetype(value);
  // @@protoc_insertion_point(field_set:proto.Device.DeviceType)
}

// string IPAddress = 5;
inline void Device::clear_ipaddress() {
  ipaddress_.ClearToEmpty();
}
inline const std::string& Device::ipaddress() const {
  // @@protoc_insertion_point(field_get:proto.Device.IPAddress)
  return _internal_ipaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Device::set_ipaddress(ArgT0&& arg0, ArgT... args) {
 
 ipaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Device.IPAddress)
}
inline std::string* Device::mutable_ipaddress() {
  std::string* _s = _internal_mutable_ipaddress();
  // @@protoc_insertion_point(field_mutable:proto.Device.IPAddress)
  return _s;
}
inline const std::string& Device::_internal_ipaddress() const {
  return ipaddress_.Get();
}
inline void Device::_internal_set_ipaddress(const std::string& value) {
  
  ipaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Device::_internal_mutable_ipaddress() {
  
  return ipaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Device::release_ipaddress() {
  // @@protoc_insertion_point(field_release:proto.Device.IPAddress)
  return ipaddress_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Device::set_allocated_ipaddress(std::string* ipaddress) {
  if (ipaddress != nullptr) {
    
  } else {
    
  }
  ipaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ipaddress,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:proto.Device.IPAddress)
}

// string Gateway = 6;
inline void Device::clear_gateway() {
  gateway_.ClearToEmpty();
}
inline const std::string& Device::gateway() const {
  // @@protoc_insertion_point(field_get:proto.Device.Gateway)
  return _internal_gateway();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Device::set_gateway(ArgT0&& arg0, ArgT... args) {
 
 gateway_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Device.Gateway)
}
inline std::string* Device::mutable_gateway() {
  std::string* _s = _internal_mutable_gateway();
  // @@protoc_insertion_point(field_mutable:proto.Device.Gateway)
  return _s;
}
inline const std::string& Device::_internal_gateway() const {
  return gateway_.Get();
}
inline void Device::_internal_set_gateway(const std::string& value) {
  
  gateway_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Device::_internal_mutable_gateway() {
  
  return gateway_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Device::release_gateway() {
  // @@protoc_insertion_point(field_release:proto.Device.Gateway)
  return gateway_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Device::set_allocated_gateway(std::string* gateway) {
  if (gateway != nullptr) {
    
  } else {
    
  }
  gateway_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gateway,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:proto.Device.Gateway)
}

// string SubnetMask = 7;
inline void Device::clear_subnetmask() {
  subnetmask_.ClearToEmpty();
}
inline const std::string& Device::subnetmask() const {
  // @@protoc_insertion_point(field_get:proto.Device.SubnetMask)
  return _internal_subnetmask();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Device::set_subnetmask(ArgT0&& arg0, ArgT... args) {
 
 subnetmask_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Device.SubnetMask)
}
inline std::string* Device::mutable_subnetmask() {
  std::string* _s = _internal_mutable_subnetmask();
  // @@protoc_insertion_point(field_mutable:proto.Device.SubnetMask)
  return _s;
}
inline const std::string& Device::_internal_subnetmask() const {
  return subnetmask_.Get();
}
inline void Device::_internal_set_subnetmask(const std::string& value) {
  
  subnetmask_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Device::_internal_mutable_subnetmask() {
  
  return subnetmask_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Device::release_subnetmask() {
  // @@protoc_insertion_point(field_release:proto.Device.SubnetMask)
  return subnetmask_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Device::set_allocated_subnetmask(std::string* subnetmask) {
  if (subnetmask != nullptr) {
    
  } else {
    
  }
  subnetmask_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subnetmask,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:proto.Device.SubnetMask)
}

// string OPCUrl = 8;
inline void Device::clear_opcurl() {
  opcurl_.ClearToEmpty();
}
inline const std::string& Device::opcurl() const {
  // @@protoc_insertion_point(field_get:proto.Device.OPCUrl)
  return _internal_opcurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Device::set_opcurl(ArgT0&& arg0, ArgT... args) {
 
 opcurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Device.OPCUrl)
}
inline std::string* Device::mutable_opcurl() {
  std::string* _s = _internal_mutable_opcurl();
  // @@protoc_insertion_point(field_mutable:proto.Device.OPCUrl)
  return _s;
}
inline const std::string& Device::_internal_opcurl() const {
  return opcurl_.Get();
}
inline void Device::_internal_set_opcurl(const std::string& value) {
  
  opcurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Device::_internal_mutable_opcurl() {
  
  return opcurl_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Device::release_opcurl() {
  // @@protoc_insertion_point(field_release:proto.Device.OPCUrl)
  return opcurl_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Device::set_allocated_opcurl(std::string* opcurl) {
  if (opcurl != nullptr) {
    
  } else {
    
  }
  opcurl_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), opcurl,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:proto.Device.OPCUrl)
}

// -------------------------------------------------------------------

// Sensor

// uint32 ID = 1;
inline void Sensor::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Sensor::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Sensor::id() const {
  // @@protoc_insertion_point(field_get:proto.Sensor.ID)
  return _internal_id();
}
inline void Sensor::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void Sensor::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:proto.Sensor.ID)
}

// uint32 DeviceID = 2;
inline void Sensor::clear_deviceid() {
  deviceid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Sensor::_internal_deviceid() const {
  return deviceid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Sensor::deviceid() const {
  // @@protoc_insertion_point(field_get:proto.Sensor.DeviceID)
  return _internal_deviceid();
}
inline void Sensor::_internal_set_deviceid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  deviceid_ = value;
}
inline void Sensor::set_deviceid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_deviceid(value);
  // @@protoc_insertion_point(field_set:proto.Sensor.DeviceID)
}

// string Name = 3;
inline void Sensor::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Sensor::name() const {
  // @@protoc_insertion_point(field_get:proto.Sensor.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Sensor::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Sensor.Name)
}
inline std::string* Sensor::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.Sensor.Name)
  return _s;
}
inline const std::string& Sensor::_internal_name() const {
  return name_.Get();
}
inline void Sensor::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Sensor::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Sensor::release_name() {
  // @@protoc_insertion_point(field_release:proto.Sensor.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Sensor::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:proto.Sensor.Name)
}

// string Location = 4;
inline void Sensor::clear_location() {
  location_.ClearToEmpty();
}
inline const std::string& Sensor::location() const {
  // @@protoc_insertion_point(field_get:proto.Sensor.Location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Sensor::set_location(ArgT0&& arg0, ArgT... args) {
 
 location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Sensor.Location)
}
inline std::string* Sensor::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:proto.Sensor.Location)
  return _s;
}
inline const std::string& Sensor::_internal_location() const {
  return location_.Get();
}
inline void Sensor::_internal_set_location(const std::string& value) {
  
  location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Sensor::_internal_mutable_location() {
  
  return location_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Sensor::release_location() {
  // @@protoc_insertion_point(field_release:proto.Sensor.Location)
  return location_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Sensor::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  location_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), location,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:proto.Sensor.Location)
}

// .proto.SensorDataType DataType = 5;
inline void Sensor::clear_datatype() {
  datatype_ = 0;
}
inline ::proto::SensorDataType Sensor::_internal_datatype() const {
  return static_cast< ::proto::SensorDataType >(datatype_);
}
inline ::proto::SensorDataType Sensor::datatype() const {
  // @@protoc_insertion_point(field_get:proto.Sensor.DataType)
  return _internal_datatype();
}
inline void Sensor::_internal_set_datatype(::proto::SensorDataType value) {
  
  datatype_ = value;
}
inline void Sensor::set_datatype(::proto::SensorDataType value) {
  _internal_set_datatype(value);
  // @@protoc_insertion_point(field_set:proto.Sensor.DataType)
}

// int32 GPIONum = 6;
inline void Sensor::clear_gpionum() {
  gpionum_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Sensor::_internal_gpionum() const {
  return gpionum_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Sensor::gpionum() const {
  // @@protoc_insertion_point(field_get:proto.Sensor.GPIONum)
  return _internal_gpionum();
}
inline void Sensor::_internal_set_gpionum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gpionum_ = value;
}
inline void Sensor::set_gpionum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_gpionum(value);
  // @@protoc_insertion_point(field_set:proto.Sensor.GPIONum)
}

// .proto.GPIOType GPIOType = 7;
inline void Sensor::clear_gpiotype() {
  gpiotype_ = 0;
}
inline ::proto::GPIOType Sensor::_internal_gpiotype() const {
  return static_cast< ::proto::GPIOType >(gpiotype_);
}
inline ::proto::GPIOType Sensor::gpiotype() const {
  // @@protoc_insertion_point(field_get:proto.Sensor.GPIOType)
  return _internal_gpiotype();
}
inline void Sensor::_internal_set_gpiotype(::proto::GPIOType value) {
  
  gpiotype_ = value;
}
inline void Sensor::set_gpiotype(::proto::GPIOType value) {
  _internal_set_gpiotype(value);
  // @@protoc_insertion_point(field_set:proto.Sensor.GPIOType)
}

// bool PullUpResistor = 8;
inline void Sensor::clear_pullupresistor() {
  pullupresistor_ = false;
}
inline bool Sensor::_internal_pullupresistor() const {
  return pullupresistor_;
}
inline bool Sensor::pullupresistor() const {
  // @@protoc_insertion_point(field_get:proto.Sensor.PullUpResistor)
  return _internal_pullupresistor();
}
inline void Sensor::_internal_set_pullupresistor(bool value) {
  
  pullupresistor_ = value;
}
inline void Sensor::set_pullupresistor(bool value) {
  _internal_set_pullupresistor(value);
  // @@protoc_insertion_point(field_set:proto.Sensor.PullUpResistor)
}

// .proto.PLCDataArea PLCDataArea = 9;
inline void Sensor::clear_plcdataarea() {
  plcdataarea_ = 0;
}
inline ::proto::PLCDataArea Sensor::_internal_plcdataarea() const {
  return static_cast< ::proto::PLCDataArea >(plcdataarea_);
}
inline ::proto::PLCDataArea Sensor::plcdataarea() const {
  // @@protoc_insertion_point(field_get:proto.Sensor.PLCDataArea)
  return _internal_plcdataarea();
}
inline void Sensor::_internal_set_plcdataarea(::proto::PLCDataArea value) {
  
  plcdataarea_ = value;
}
inline void Sensor::set_plcdataarea(::proto::PLCDataArea value) {
  _internal_set_plcdataarea(value);
  // @@protoc_insertion_point(field_set:proto.Sensor.PLCDataArea)
}

// int32 DataOffset = 10;
inline void Sensor::clear_dataoffset() {
  dataoffset_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Sensor::_internal_dataoffset() const {
  return dataoffset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Sensor::dataoffset() const {
  // @@protoc_insertion_point(field_get:proto.Sensor.DataOffset)
  return _internal_dataoffset();
}
inline void Sensor::_internal_set_dataoffset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  dataoffset_ = value;
}
inline void Sensor::set_dataoffset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_dataoffset(value);
  // @@protoc_insertion_point(field_set:proto.Sensor.DataOffset)
}

// int32 BoolIndex = 11;
inline void Sensor::clear_boolindex() {
  boolindex_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Sensor::_internal_boolindex() const {
  return boolindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Sensor::boolindex() const {
  // @@protoc_insertion_point(field_get:proto.Sensor.BoolIndex)
  return _internal_boolindex();
}
inline void Sensor::_internal_set_boolindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  boolindex_ = value;
}
inline void Sensor::set_boolindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_boolindex(value);
  // @@protoc_insertion_point(field_set:proto.Sensor.BoolIndex)
}

// int32 DbNum = 12;
inline void Sensor::clear_dbnum() {
  dbnum_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Sensor::_internal_dbnum() const {
  return dbnum_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Sensor::dbnum() const {
  // @@protoc_insertion_point(field_get:proto.Sensor.DbNum)
  return _internal_dbnum();
}
inline void Sensor::_internal_set_dbnum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  dbnum_ = value;
}
inline void Sensor::set_dbnum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_dbnum(value);
  // @@protoc_insertion_point(field_set:proto.Sensor.DbNum)
}

// string NodeID = 13;
inline void Sensor::clear_nodeid() {
  nodeid_.ClearToEmpty();
}
inline const std::string& Sensor::nodeid() const {
  // @@protoc_insertion_point(field_get:proto.Sensor.NodeID)
  return _internal_nodeid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Sensor::set_nodeid(ArgT0&& arg0, ArgT... args) {
 
 nodeid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Sensor.NodeID)
}
inline std::string* Sensor::mutable_nodeid() {
  std::string* _s = _internal_mutable_nodeid();
  // @@protoc_insertion_point(field_mutable:proto.Sensor.NodeID)
  return _s;
}
inline const std::string& Sensor::_internal_nodeid() const {
  return nodeid_.Get();
}
inline void Sensor::_internal_set_nodeid(const std::string& value) {
  
  nodeid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Sensor::_internal_mutable_nodeid() {
  
  return nodeid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Sensor::release_nodeid() {
  // @@protoc_insertion_point(field_release:proto.Sensor.NodeID)
  return nodeid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Sensor::set_allocated_nodeid(std::string* nodeid) {
  if (nodeid != nullptr) {
    
  } else {
    
  }
  nodeid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nodeid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:proto.Sensor.NodeID)
}

// -------------------------------------------------------------------

// Record

// uint32 ID = 1;
inline void Record::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Record::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Record::id() const {
  // @@protoc_insertion_point(field_get:proto.Record.ID)
  return _internal_id();
}
inline void Record::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void Record::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:proto.Record.ID)
}

// uint32 DeviceID = 2;
inline void Record::clear_deviceid() {
  deviceid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Record::_internal_deviceid() const {
  return deviceid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Record::deviceid() const {
  // @@protoc_insertion_point(field_get:proto.Record.DeviceID)
  return _internal_deviceid();
}
inline void Record::_internal_set_deviceid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  deviceid_ = value;
}
inline void Record::set_deviceid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_deviceid(value);
  // @@protoc_insertion_point(field_set:proto.Record.DeviceID)
}

// string Name = 3;
inline void Record::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Record::name() const {
  // @@protoc_insertion_point(field_get:proto.Record.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Record::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Record.Name)
}
inline std::string* Record::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.Record.Name)
  return _s;
}
inline const std::string& Record::_internal_name() const {
  return name_.Get();
}
inline void Record::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Record::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Record::release_name() {
  // @@protoc_insertion_point(field_release:proto.Record.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Record::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:proto.Record.Name)
}

// bool Running = 4;
inline void Record::clear_running() {
  running_ = false;
}
inline bool Record::_internal_running() const {
  return running_;
}
inline bool Record::running() const {
  // @@protoc_insertion_point(field_get:proto.Record.Running)
  return _internal_running();
}
inline void Record::_internal_set_running(bool value) {
  
  running_ = value;
}
inline void Record::set_running(bool value) {
  _internal_set_running(value);
  // @@protoc_insertion_point(field_set:proto.Record.Running)
}

// repeated .proto.RecordSensor RecordSensor = 5;
inline int Record::_internal_recordsensor_size() const {
  return recordsensor_.size();
}
inline int Record::recordsensor_size() const {
  return _internal_recordsensor_size();
}
inline void Record::clear_recordsensor() {
  recordsensor_.Clear();
}
inline ::proto::RecordSensor* Record::mutable_recordsensor(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Record.RecordSensor)
  return recordsensor_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::RecordSensor >*
Record::mutable_recordsensor() {
  // @@protoc_insertion_point(field_mutable_list:proto.Record.RecordSensor)
  return &recordsensor_;
}
inline const ::proto::RecordSensor& Record::_internal_recordsensor(int index) const {
  return recordsensor_.Get(index);
}
inline const ::proto::RecordSensor& Record::recordsensor(int index) const {
  // @@protoc_insertion_point(field_get:proto.Record.RecordSensor)
  return _internal_recordsensor(index);
}
inline ::proto::RecordSensor* Record::_internal_add_recordsensor() {
  return recordsensor_.Add();
}
inline ::proto::RecordSensor* Record::add_recordsensor() {
  ::proto::RecordSensor* _add = _internal_add_recordsensor();
  // @@protoc_insertion_point(field_add:proto.Record.RecordSensor)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::RecordSensor >&
Record::recordsensor() const {
  // @@protoc_insertion_point(field_list:proto.Record.RecordSensor)
  return recordsensor_;
}

// -------------------------------------------------------------------

// RecordSensor

// uint32 SensorID = 1;
inline void RecordSensor::clear_sensorid() {
  sensorid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RecordSensor::_internal_sensorid() const {
  return sensorid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RecordSensor::sensorid() const {
  // @@protoc_insertion_point(field_get:proto.RecordSensor.SensorID)
  return _internal_sensorid();
}
inline void RecordSensor::_internal_set_sensorid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sensorid_ = value;
}
inline void RecordSensor::set_sensorid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sensorid(value);
  // @@protoc_insertion_point(field_set:proto.RecordSensor.SensorID)
}

// .proto.RecordType RecordType = 2;
inline void RecordSensor::clear_recordtype() {
  recordtype_ = 0;
}
inline ::proto::RecordType RecordSensor::_internal_recordtype() const {
  return static_cast< ::proto::RecordType >(recordtype_);
}
inline ::proto::RecordType RecordSensor::recordtype() const {
  // @@protoc_insertion_point(field_get:proto.RecordSensor.RecordType)
  return _internal_recordtype();
}
inline void RecordSensor::_internal_set_recordtype(::proto::RecordType value) {
  
  recordtype_ = value;
}
inline void RecordSensor::set_recordtype(::proto::RecordType value) {
  _internal_set_recordtype(value);
  // @@protoc_insertion_point(field_set:proto.RecordSensor.RecordType)
}

// string TriggerValueMin = 3;
inline void RecordSensor::clear_triggervaluemin() {
  triggervaluemin_.ClearToEmpty();
}
inline const std::string& RecordSensor::triggervaluemin() const {
  // @@protoc_insertion_point(field_get:proto.RecordSensor.TriggerValueMin)
  return _internal_triggervaluemin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecordSensor::set_triggervaluemin(ArgT0&& arg0, ArgT... args) {
 
 triggervaluemin_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.RecordSensor.TriggerValueMin)
}
inline std::string* RecordSensor::mutable_triggervaluemin() {
  std::string* _s = _internal_mutable_triggervaluemin();
  // @@protoc_insertion_point(field_mutable:proto.RecordSensor.TriggerValueMin)
  return _s;
}
inline const std::string& RecordSensor::_internal_triggervaluemin() const {
  return triggervaluemin_.Get();
}
inline void RecordSensor::_internal_set_triggervaluemin(const std::string& value) {
  
  triggervaluemin_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RecordSensor::_internal_mutable_triggervaluemin() {
  
  return triggervaluemin_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RecordSensor::release_triggervaluemin() {
  // @@protoc_insertion_point(field_release:proto.RecordSensor.TriggerValueMin)
  return triggervaluemin_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RecordSensor::set_allocated_triggervaluemin(std::string* triggervaluemin) {
  if (triggervaluemin != nullptr) {
    
  } else {
    
  }
  triggervaluemin_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), triggervaluemin,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:proto.RecordSensor.TriggerValueMin)
}

// string TriggerValueMax = 4;
inline void RecordSensor::clear_triggervaluemax() {
  triggervaluemax_.ClearToEmpty();
}
inline const std::string& RecordSensor::triggervaluemax() const {
  // @@protoc_insertion_point(field_get:proto.RecordSensor.TriggerValueMax)
  return _internal_triggervaluemax();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecordSensor::set_triggervaluemax(ArgT0&& arg0, ArgT... args) {
 
 triggervaluemax_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.RecordSensor.TriggerValueMax)
}
inline std::string* RecordSensor::mutable_triggervaluemax() {
  std::string* _s = _internal_mutable_triggervaluemax();
  // @@protoc_insertion_point(field_mutable:proto.RecordSensor.TriggerValueMax)
  return _s;
}
inline const std::string& RecordSensor::_internal_triggervaluemax() const {
  return triggervaluemax_.Get();
}
inline void RecordSensor::_internal_set_triggervaluemax(const std::string& value) {
  
  triggervaluemax_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RecordSensor::_internal_mutable_triggervaluemax() {
  
  return triggervaluemax_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RecordSensor::release_triggervaluemax() {
  // @@protoc_insertion_point(field_release:proto.RecordSensor.TriggerValueMax)
  return triggervaluemax_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RecordSensor::set_allocated_triggervaluemax(std::string* triggervaluemax) {
  if (triggervaluemax != nullptr) {
    
  } else {
    
  }
  triggervaluemax_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), triggervaluemax,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:proto.RecordSensor.TriggerValueMax)
}

// double interval = 5;
inline void RecordSensor::clear_interval() {
  interval_ = 0;
}
inline double RecordSensor::_internal_interval() const {
  return interval_;
}
inline double RecordSensor::interval() const {
  // @@protoc_insertion_point(field_get:proto.RecordSensor.interval)
  return _internal_interval();
}
inline void RecordSensor::_internal_set_interval(double value) {
  
  interval_ = value;
}
inline void RecordSensor::set_interval(double value) {
  _internal_set_interval(value);
  // @@protoc_insertion_point(field_set:proto.RecordSensor.interval)
}

// -------------------------------------------------------------------

// RecordData

// uint32 ID = 1;
inline void RecordData::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RecordData::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RecordData::id() const {
  // @@protoc_insertion_point(field_get:proto.RecordData.ID)
  return _internal_id();
}
inline void RecordData::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void RecordData::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:proto.RecordData.ID)
}

// uint32 SensorID = 2;
inline void RecordData::clear_sensorid() {
  sensorid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RecordData::_internal_sensorid() const {
  return sensorid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RecordData::sensorid() const {
  // @@protoc_insertion_point(field_get:proto.RecordData.SensorID)
  return _internal_sensorid();
}
inline void RecordData::_internal_set_sensorid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sensorid_ = value;
}
inline void RecordData::set_sensorid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sensorid(value);
  // @@protoc_insertion_point(field_set:proto.RecordData.SensorID)
}

// .proto.SensorDataType DataType = 3;
inline void RecordData::clear_datatype() {
  datatype_ = 0;
}
inline ::proto::SensorDataType RecordData::_internal_datatype() const {
  return static_cast< ::proto::SensorDataType >(datatype_);
}
inline ::proto::SensorDataType RecordData::datatype() const {
  // @@protoc_insertion_point(field_get:proto.RecordData.DataType)
  return _internal_datatype();
}
inline void RecordData::_internal_set_datatype(::proto::SensorDataType value) {
  
  datatype_ = value;
}
inline void RecordData::set_datatype(::proto::SensorDataType value) {
  _internal_set_datatype(value);
  // @@protoc_insertion_point(field_set:proto.RecordData.DataType)
}

// string Value = 4;
inline void RecordData::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& RecordData::value() const {
  // @@protoc_insertion_point(field_get:proto.RecordData.Value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecordData::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.RecordData.Value)
}
inline std::string* RecordData::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:proto.RecordData.Value)
  return _s;
}
inline const std::string& RecordData::_internal_value() const {
  return value_.Get();
}
inline void RecordData::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RecordData::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RecordData::release_value() {
  // @@protoc_insertion_point(field_release:proto.RecordData.Value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RecordData::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:proto.RecordData.Value)
}

// .google.protobuf.Timestamp Timestamp = 5;
inline bool RecordData::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool RecordData::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& RecordData::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& RecordData::timestamp() const {
  // @@protoc_insertion_point(field_get:proto.RecordData.Timestamp)
  return _internal_timestamp();
}
inline void RecordData::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RecordData.Timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* RecordData::release_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* RecordData::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:proto.RecordData.Timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* RecordData::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* RecordData::mutable_timestamp() {
  PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:proto.RecordData.Timestamp)
  return _msg;
}
inline void RecordData::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:proto.RecordData.Timestamp)
}

// -------------------------------------------------------------------

// RecordDataFilter

// uint32 ID = 1;
inline void RecordDataFilter::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RecordDataFilter::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RecordDataFilter::id() const {
  // @@protoc_insertion_point(field_get:proto.RecordDataFilter.ID)
  return _internal_id();
}
inline void RecordDataFilter::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void RecordDataFilter::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:proto.RecordDataFilter.ID)
}

// uint32 SensorID = 2;
inline void RecordDataFilter::clear_sensorid() {
  sensorid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RecordDataFilter::_internal_sensorid() const {
  return sensorid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RecordDataFilter::sensorid() const {
  // @@protoc_insertion_point(field_get:proto.RecordDataFilter.SensorID)
  return _internal_sensorid();
}
inline void RecordDataFilter::_internal_set_sensorid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sensorid_ = value;
}
inline void RecordDataFilter::set_sensorid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sensorid(value);
  // @@protoc_insertion_point(field_set:proto.RecordDataFilter.SensorID)
}

// .proto.FilterValue FilterValue = 3;
inline void RecordDataFilter::clear_filtervalue() {
  filtervalue_ = 0;
}
inline ::proto::FilterValue RecordDataFilter::_internal_filtervalue() const {
  return static_cast< ::proto::FilterValue >(filtervalue_);
}
inline ::proto::FilterValue RecordDataFilter::filtervalue() const {
  // @@protoc_insertion_point(field_get:proto.RecordDataFilter.FilterValue)
  return _internal_filtervalue();
}
inline void RecordDataFilter::_internal_set_filtervalue(::proto::FilterValue value) {
  
  filtervalue_ = value;
}
inline void RecordDataFilter::set_filtervalue(::proto::FilterValue value) {
  _internal_set_filtervalue(value);
  // @@protoc_insertion_point(field_set:proto.RecordDataFilter.FilterValue)
}

// string MinValue = 4;
inline void RecordDataFilter::clear_minvalue() {
  minvalue_.ClearToEmpty();
}
inline const std::string& RecordDataFilter::minvalue() const {
  // @@protoc_insertion_point(field_get:proto.RecordDataFilter.MinValue)
  return _internal_minvalue();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecordDataFilter::set_minvalue(ArgT0&& arg0, ArgT... args) {
 
 minvalue_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.RecordDataFilter.MinValue)
}
inline std::string* RecordDataFilter::mutable_minvalue() {
  std::string* _s = _internal_mutable_minvalue();
  // @@protoc_insertion_point(field_mutable:proto.RecordDataFilter.MinValue)
  return _s;
}
inline const std::string& RecordDataFilter::_internal_minvalue() const {
  return minvalue_.Get();
}
inline void RecordDataFilter::_internal_set_minvalue(const std::string& value) {
  
  minvalue_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RecordDataFilter::_internal_mutable_minvalue() {
  
  return minvalue_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RecordDataFilter::release_minvalue() {
  // @@protoc_insertion_point(field_release:proto.RecordDataFilter.MinValue)
  return minvalue_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RecordDataFilter::set_allocated_minvalue(std::string* minvalue) {
  if (minvalue != nullptr) {
    
  } else {
    
  }
  minvalue_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), minvalue,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:proto.RecordDataFilter.MinValue)
}

// string MaxValue = 6;
inline void RecordDataFilter::clear_maxvalue() {
  maxvalue_.ClearToEmpty();
}
inline const std::string& RecordDataFilter::maxvalue() const {
  // @@protoc_insertion_point(field_get:proto.RecordDataFilter.MaxValue)
  return _internal_maxvalue();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecordDataFilter::set_maxvalue(ArgT0&& arg0, ArgT... args) {
 
 maxvalue_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.RecordDataFilter.MaxValue)
}
inline std::string* RecordDataFilter::mutable_maxvalue() {
  std::string* _s = _internal_mutable_maxvalue();
  // @@protoc_insertion_point(field_mutable:proto.RecordDataFilter.MaxValue)
  return _s;
}
inline const std::string& RecordDataFilter::_internal_maxvalue() const {
  return maxvalue_.Get();
}
inline void RecordDataFilter::_internal_set_maxvalue(const std::string& value) {
  
  maxvalue_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RecordDataFilter::_internal_mutable_maxvalue() {
  
  return maxvalue_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RecordDataFilter::release_maxvalue() {
  // @@protoc_insertion_point(field_release:proto.RecordDataFilter.MaxValue)
  return maxvalue_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RecordDataFilter::set_allocated_maxvalue(std::string* maxvalue) {
  if (maxvalue != nullptr) {
    
  } else {
    
  }
  maxvalue_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), maxvalue,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:proto.RecordDataFilter.MaxValue)
}

// .proto.FilterTime FilterTime = 8;
inline void RecordDataFilter::clear_filtertime() {
  filtertime_ = 0;
}
inline ::proto::FilterTime RecordDataFilter::_internal_filtertime() const {
  return static_cast< ::proto::FilterTime >(filtertime_);
}
inline ::proto::FilterTime RecordDataFilter::filtertime() const {
  // @@protoc_insertion_point(field_get:proto.RecordDataFilter.FilterTime)
  return _internal_filtertime();
}
inline void RecordDataFilter::_internal_set_filtertime(::proto::FilterTime value) {
  
  filtertime_ = value;
}
inline void RecordDataFilter::set_filtertime(::proto::FilterTime value) {
  _internal_set_filtertime(value);
  // @@protoc_insertion_point(field_set:proto.RecordDataFilter.FilterTime)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::proto::DeviceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::DeviceType>() {
  return ::proto::DeviceType_descriptor();
}
template <> struct is_proto_enum< ::proto::SensorDataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::SensorDataType>() {
  return ::proto::SensorDataType_descriptor();
}
template <> struct is_proto_enum< ::proto::GPIOType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::GPIOType>() {
  return ::proto::GPIOType_descriptor();
}
template <> struct is_proto_enum< ::proto::PLCDataArea> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::PLCDataArea>() {
  return ::proto::PLCDataArea_descriptor();
}
template <> struct is_proto_enum< ::proto::RecordType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::RecordType>() {
  return ::proto::RecordType_descriptor();
}
template <> struct is_proto_enum< ::proto::FilterTime> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::FilterTime>() {
  return ::proto::FilterTime_descriptor();
}
template <> struct is_proto_enum< ::proto::FilterValue> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::FilterValue>() {
  return ::proto::FilterValue_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_IoT_2eproto
